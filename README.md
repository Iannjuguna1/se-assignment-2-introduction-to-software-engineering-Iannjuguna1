[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15307665&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
1. Define Software Engineering:
Software engineering is the systematic application of engineering principles, methods and tools to the development and maintainnce of high-quality software systems 

b)What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):
It involves the design, development,testing, deployment and maintainance of software products. software engineering leverages the SDLC and other methodologies to build software in a more organized, reliable, and maintainable way compared to traditional programming approaches that might be more ad-hoc and focused solely on writing code.
(https://medium.com/@taimoornathoka007/the-pros-and-cons-of-machine-learning-and-traditional-programming-d9258c840e5f)


2. Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:

      1. equirement Gathering: Identifying the needs and expectations of the stakeholders (users, clients) for the software.
      2. System Design: Defining the overall architecture, components, and functionalities of the software.
      3. Development: Writing the actual software code based on the design specifications.
      4. Testing: Evaluating the software for functionality, performance, and security flaws.
      5. Deployment: Releasing the software to the end users.
      6. Maintenance: Fixing bugs, adding new features, and updating the software over time.
(https://en.wikipedia.org/wiki/Waterfall_model)

3. Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:
waterfall model follows a linear, step-by-step approach. Each phase (planning, design, development, testing, deployment) must be completed entirely before moving to the next ideal for Stable requirements and large projects(mobile application) while agile development happens in short, time-boxed cycles (sprints) with continuous delivery of working features suited for evolving requirements and rapid feedback.(user interface)
    key differences;
      1. waterfall model is Sequential and linear while agile is Iterative and incremental
      2. waterfall model requirements are wel defined while agile requirements are Flexible and adaptable
      3. waterfall model requires well defined documentation while agile is lighter and focuses on processes.
 (https://www.pmi.org/learning/library/agile-versus-waterfall-approach-erp-project-6300)


4.What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:
Requirements engineering (RE) is a crucial process in the software development lifecycle (SDLC) that focuses on defining, documenting, and managing the needs and expectations of all stakeholders (users, clients, developers) for the software being built. It acts as the bridge between the problem the software aims to solve and the actual solution that will be implemented.
    processes include;
                1. Requirements Elicitation-This is the initial phase where you gather information about what the software needs to do. It involves techniques like interviews, workshops, user observation, and document analysis.
                2. Requirements Analysis-The gathered information is analyzed to identify core functionalities, user needs, system constraints, and potential conflicts. This phase helps clarify and refine the requirements.
                3. Requirements Specification-Here, the well-defined and documented requirements are captured in a formal document, such as a Software Requirements Specification (SRS). This document serves as a blueprint for the development team.
                4. Requirements Verification and Validation- This phase ensures that the documented requirements accurately reflect the needs of the stakeholders. Verification confirms the requirements are consistent and complete internally. Validation confirms they actually address the intended problem or user needs.
                5. Requirements Management-As the project progresses, requirements may evolve or change. This phase involves managing these changes, ensuring all stakeholders are informed, and updating the SRS accordingly.
(https://en.wikipedia.org/wiki/Requirements_engineering)


5. Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:
Modularity is a fundamental principle in software design that emphasizes dividing a software system into smaller, self-contained units called modules. These modules are designed to perform specific, well-defined tasks and interact with each other through defined interfaces. Modular software allows you to build large and intricate systems by assembling smaller, reusable components. example is breaking a software into components that can work as one entity.
(https://www.geeksforgeeks.org/modularity-and-its-properties/)


6.Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:
Software testing is an essential process in the software development lifecycle (SDLC) that ensures the software functions as intended, meets user requirements, and is free of errors
                    1. Unit Testing-The foundation of software testing, it focuses on individual units of code.
                    2. Integration Testing-This level focuses on how well different modules or units work together to achieve a specific functionality.
                    3. System Testing-the entire software system is tested as a whole to ensure it meets the overall functional and non-functional requirements.
                    4. Acceptance Testing-the final stage where the software is validated by the end-users or stakeholders.
                    5. Acceptance testing aims to ensure the software meets their specific needs and expectations.
(https://www.guru99.com/levels-of-testing.html)


7.What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:
Version control systems (VCS) are essential tools in software development.  They act as a central repository that tracks changes made to code, files, and data over time.This allows developers to:Collaborate Effectively, Revert to Previous Versions and Track Project History.
example 
Git:  The most widely used distributed VCS. It allows developers to have a complete copy of the codebase (repository) on their local machines. This enables offline work and distributed collaboration. Git offers powerful features like branching, merging, and conflict resolution.

(https://en.wikipedia.org/wiki/Version_control)



8.Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:
software project manager is the maestro of the development team, leading and guiding the entire software development lifecycle (SDLC) to ensure successful project completion. They wear many hats, acting as a leader, communicator, facilitator, and problem-solver, all rolled into one.

key responsibilities of a software project manager:
                  1. Project Planning & Scope Definition
                  2. Team Leadership & Communication
                  3. Risk Management & Problem-Solving
                  4. Quality Assurance
                  5. Client/Stakeholder Management
challenges include:
                  1. Scope Creep & Changing Requirements
                  2. Meeting Deadlines & Budget Constraints
                  3. Team Management & Communication Issues
                  4. Technological Advancements
(https://www.pmi.org/pmbok-guide-standards/foundational/pmbok)


9. Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:
Software maintenance refers to the process of modifying and updating a software system after it has been deployed. It goes beyond simply fixing bugs and encompasses a wide range of activities to ensure the software remains functional, secure, and meets the evolving needs of its users. Maintainance is essential as it ensures functionality & Security.
types of maintenance activities:
            1. Corrective Maintenance: This involves fixing bugs and errors
            2. Preventive Maintenance: This proactive approach focuses on preventing problems before they occur.
            3. Perfective Maintenance: This type of maintenance aims to enhance the software's functionality, usability, or performance. 
            4. Adaptive Maintenance: This focuses on adapting the software to accommodate changes in the external environment.
(https://en.wikipedia.org/wiki/Software_maintenance)



10. What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?

  1. Privacy Concerns:  Software engineers often handle sensitive user data. 
  2. Algorithmic Bias:  Algorithms can perpetuate biases present in the data they are trained on.  Software engineers need to be aware of potential biases and take steps to mitigate them, ensuring algorithms are fair and unbiased in their decision-making.
  3. Security Vulnerabilities:  Software engineers have a responsibility to write secure code and identify potential security vulnerabilities.  Releasing software with known vulnerabilities can expose users to security risks and data breaches.
  4. Intellectual Property (IP) Rights:  Software engineers need to be mindful of copyright and licensing issues. This includes using licensed software and libraries appropriately and respecting the intellectual property of others.
  5. Automation and Job Displacement:  Automation through software can lead to job displacement in certain sectors.  Software engineers should consider the ethical implications of their work and advocate for responsible development of automation technologies.
  6. Dark Patterns:  Deceptive design practices that manipulate users into taking unwanted actions raise ethical concerns.  Software engineers should avoid implementing "dark patterns" in their interfaces and promote ethical user experiences.

(https://www.acm.org/code-of-ethics)








Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
